/*
在一张地图上玩家可以选定n个平行于坐标轴的矩形区域，各个矩形区域之间可以有重叠，
这些区域组成了一个新的图形，你需要给出这个图形所有的顶点坐标。

输入描述：
第一行输入一个整数n(1<=n<=500)，表示玩家选定的矩形区域的个数
接下来的n行，每行四个整数x1,y1,x2,y2(1<=x1,y1,x2,y2<=2000000,x1<x2,y1<y2)，
代表玩家选中的矩形的对角坐标。

输出描述：
输出多行，每行两个整数x和y，代表矩形区域组成的图形的坐标。
输出的坐标按照x排序，当x相同时按照y升序。
*/
/*
 分析：
    先考虑n=1时的情况，此时，输出这个矩形的四个角的坐标即可
    例如(1,1)(2,2)
    输出(1,1)
        (1,2)
        (2,1)
        (2,2)即可
    其他两个坐标由对角坐标计算（因为x1<x2,y1<y2）所以只能输入右上与左下的坐标
    左上坐标为x=x2-x1,y=y2  右下的坐标为x=x1,y=y2-y1
    当有两个矩形时先提取最大的x坐标
    n=2时，有两个矩形，当一个矩形的都小于第二个矩形的时候，或者第二个矩形中
    有一个坐标等于第一个矩形，且其它的坐标都小于第一个矩形，这种叫包含或者相切
    其他情况就是两个矩形套在一起了
    对于第一种情况，取最大的矩形的x，y坐标即可
    统计所有矩形的四个坐标，并依次判断
*/
int main(){
    //矩形的个数
    int n;
    cin>>n;
    //存放矩形坐标，方式为左下，右上，左上，右下
    vector<vector<int>>dp(n,vector<int>(4,0));
    for(int i=0;i<n;i++){
        for(int j=0;j<4;j++){
            cin>>dp[i][j];
        }
    }
    //写入每一个矩形剩下的左上与右下的坐标
    //方式为左上=(x2-x1,y2),右下(x2,y2-y1)
    for(int i=0;i<n;i++){
        vector<int>temp(4,0);
        temp[0]=dp[i][2]-dp[i][0];
        temp[1]=dp[i][3];
        temp[2]=dp[i][2];
        temp[3]=dp[i][3]-dp[i][1];
        for(int j=0;j<4;j++){
            dp[i].push_back(temp[j]);
        }     
    }
    //先取x最小的坐标,以及最小坐标对应的y坐标
    vector<int>x_min;
    for(int i=0;i<n;i++){
        x_min[i]=min(x_min[i],dp[i][0]);
    }

}